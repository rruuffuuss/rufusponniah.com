<canvas id="canvas"></canvas>

<script id="update-vertex" type="x-shader/x-vertex">#version 300 es // WebGL2 uses GLSL ES 3.0

  // Vertex position input
  in vec2 aPosition;
  
  // Output texture coordinates to the fragment shader
  out vec2 vTexCoord;
  
  void main() {
      // Map the vertex positions from [-1, 1] (NDC) to [0, 1] for texture coordinates
      vTexCoord = (aPosition + 1.0) * 0.5;
  
      // Set the final position of the vertex in clip space
      gl_Position = vec4(aPosition, 0.0, 1.0);
  }
</script>

<script id="update-fragment" type="x-shader/x-fragment">#version 300 es // WebGL2 uses GLSL ES 3.0
  precision mediump float;

  in vec2 vTexCoord;
  
  uniform sampler2D points;
  uniform float drag;
  uniform vec2 screen;

  out vec4 fragColor;

  void main() {
    vec4 point = texture(points, vTexCoord);

    fragColor.zw = point.xy;

    point.xy = point.xy + (point.xy - point.zw) * drag;

    //if a point is outside the bounds of the screen, swap new and old (reverse velocity) 
    if(point.x > screen.x || point.x < 0.0){
      fragColor.x = fragColor.z;
      fragColor.z = point.x;
    } else {
      fragColor.x = point.x;
    }
    if(point.y > screen.y || point.y < 0.0){
      fragColor.y = fragColor.w;
      fragColor.w = point.y;
    } else {
      fragColor.y = point.y;
    }
  }

</script>


<script src="https://greggman.github.io/webgl-lint/webgl-lint.js"></script>
<script src="webgl-utils.js"></script>
<script src="background.js"></script>


















<!-- vertex shader -->
<script id="vertex-shader" type="x-shader/x-vertex">
  in vec2 a_position;
  in vec2 a_oldPosition;
  in vec2 a_origin;
  
  out vec2 o_position;
  out vec2 o_oldPosition;
  
  out vec4 colour; 
  
  uniform float drag;
  uniform vec2 screen;
  uniform vec2 size
  uniform vec2 u_resolution;
  uniform vec4 colorCache[128]
  
  void main() {
  
    //update position to displacement between current position and previous position
    o_position = a_position + (a_position - a_oldPosition) * drag;
  
  
    //if a point is outside the bounds of the screen, swap new and old (reverse velocity) 
    if(o_position.x > screen.x || o_position.x < 0.0){
      o_oldPosition.x = o_position.x;
      o_position = a_position.x;
    } else {
      o_oldPosition.x = a_position.x;
    }
  
    if(o_position.y > screen.y || o_position.y < 0.0){
      o_oldPosition.y = o_position.y;
      o_position = a_position.y;
    } else {
      o_oldPosition.y = a_position.y;
    }
    
    //since tiles do not move, just change colour based on particle, gl_Position can be pre computed
  
  
    colour = colorCache[floor(distance(a_origin, a_position) * 5.0)];
  }
  </script>
  <!-- fragment shader -->
  <script id="fragment-shader-2d" type="x-shader/x-fragment">
  precision mediump float;
  
  in vec4 colour
  
  void main() {
     gl_FragColor = colour;
  }
  </script><!--
  